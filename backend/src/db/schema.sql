-- =====================================================
-- Gateway Success - Action Plan System Database Schema
-- =====================================================
-- All columns use snake_case naming convention
-- This schema creates tables for action plan management
-- Designed to work alongside existing N8N workflows

-- =====================================================
-- 1. ACTION PLAN DRAFTS TABLE
-- =====================================================
-- Stores AI-generated draft action plans before confirmation
-- Used by N8N workflow: generate_action_plan, refine_action_plan

CREATE TABLE IF NOT EXISTS action_plan_drafts (
  id SERIAL PRIMARY KEY,
  assessment_run_id INTEGER REFERENCES assessment_runs(id) ON DELETE CASCADE,
  draft_data JSONB NOT NULL,
  conversation_history JSONB DEFAULT '[]'::jsonb,
  draft_status VARCHAR(50) DEFAULT 'editing' CHECK (draft_status IN ('editing', 'confirmed', 'cancelled')),
  created_by INTEGER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_action_plan_drafts_assessment_run ON action_plan_drafts(assessment_run_id);
CREATE INDEX IF NOT EXISTS idx_action_plan_drafts_status ON action_plan_drafts(draft_status);

COMMENT ON TABLE action_plan_drafts IS 'Draft action plans generated by AI, before user confirmation';
COMMENT ON COLUMN action_plan_drafts.draft_data IS 'JSONB containing proposed actions array';
COMMENT ON COLUMN action_plan_drafts.conversation_history IS 'AI chat history for refinement iterations';

-- =====================================================
-- 2. ACTIONS TABLE
-- =====================================================
-- Main actions table for confirmed action items

CREATE TABLE IF NOT EXISTS actions (
  id SERIAL PRIMARY KEY,
  project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  source_assessment_run_id INTEGER REFERENCES assessment_runs(id),
  title VARCHAR(255) NOT NULL,
  description TEXT,
  action_status VARCHAR(50) DEFAULT 'not_started' CHECK (action_status IN ('not_started', 'in_progress', 'blocked', 'completed', 'cancelled')),
  priority VARCHAR(20) DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'critical')),
  assigned_to INTEGER REFERENCES users(id),
  due_date DATE,
  completed_at TIMESTAMP,
  created_by INTEGER REFERENCES users(id),
  updated_by INTEGER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_actions_project_id ON actions(project_id);
CREATE INDEX IF NOT EXISTS idx_actions_assigned_to ON actions(assigned_to);
CREATE INDEX IF NOT EXISTS idx_actions_status ON actions(action_status);
CREATE INDEX IF NOT EXISTS idx_actions_priority ON actions(priority);
CREATE INDEX IF NOT EXISTS idx_actions_due_date ON actions(due_date);
CREATE INDEX IF NOT EXISTS idx_actions_source_assessment ON actions(source_assessment_run_id);

COMMENT ON TABLE actions IS 'Confirmed action items generated from assessment findings';
COMMENT ON COLUMN actions.source_assessment_run_id IS 'Which assessment run generated this action';

-- =====================================================
-- 3. ACTION-ASSESSMENT LINKS TABLE
-- =====================================================
-- Many-to-many relationship: which assessment findings an action addresses

CREATE TABLE IF NOT EXISTS action_assessments (
  id SERIAL PRIMARY KEY,
  action_id INTEGER NOT NULL REFERENCES actions(id) ON DELETE CASCADE,
  assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(action_id, assessment_id)
);

CREATE INDEX IF NOT EXISTS idx_action_assessments_action ON action_assessments(action_id);
CREATE INDEX IF NOT EXISTS idx_action_assessments_assessment ON action_assessments(assessment_id);

COMMENT ON TABLE action_assessments IS 'Links actions to the assessment findings they address';

-- =====================================================
-- 4. ACTION HISTORY TABLE
-- =====================================================
-- Audit log of all changes to actions (auto-populated by trigger)

CREATE TABLE IF NOT EXISTS action_history (
  id SERIAL PRIMARY KEY,
  action_id INTEGER NOT NULL REFERENCES actions(id) ON DELETE CASCADE,
  changed_by INTEGER REFERENCES users(id),
  field_changed VARCHAR(100) NOT NULL,
  old_value TEXT,
  new_value TEXT,
  changed_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_action_history_action_id ON action_history(action_id);
CREATE INDEX IF NOT EXISTS idx_action_history_changed_at ON action_history(changed_at);

COMMENT ON TABLE action_history IS 'Audit trail of all action changes (auto-populated by trigger)';

-- =====================================================
-- 5. ACTION COMMENTS TABLE
-- =====================================================
-- Comments and discussion on actions (with threading support)

CREATE TABLE IF NOT EXISTS action_comments (
  id SERIAL PRIMARY KEY,
  action_id INTEGER NOT NULL REFERENCES actions(id) ON DELETE CASCADE,
  user_id INTEGER NOT NULL REFERENCES users(id),
  parent_comment_id INTEGER REFERENCES action_comments(id) ON DELETE CASCADE,
  comment_text TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_action_comments_action_id ON action_comments(action_id);
CREATE INDEX IF NOT EXISTS idx_action_comments_user_id ON action_comments(user_id);
CREATE INDEX IF NOT EXISTS idx_action_comments_parent ON action_comments(parent_comment_id);

COMMENT ON TABLE action_comments IS 'Comments and discussion threads on actions';
COMMENT ON COLUMN action_comments.parent_comment_id IS 'For threaded replies (NULL = top-level comment)';

-- =====================================================
-- 6. COMMENT MENTIONS TABLE
-- =====================================================
-- Track @mentions in comments for notifications

CREATE TABLE IF NOT EXISTS comment_mentions (
  id SERIAL PRIMARY KEY,
  comment_id INTEGER NOT NULL REFERENCES action_comments(id) ON DELETE CASCADE,
  mentioned_user_id INTEGER NOT NULL REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(comment_id, mentioned_user_id)
);

CREATE INDEX IF NOT EXISTS idx_comment_mentions_user ON comment_mentions(mentioned_user_id);
CREATE INDEX IF NOT EXISTS idx_comment_mentions_comment ON comment_mentions(comment_id);

COMMENT ON TABLE comment_mentions IS 'Track @user mentions in comments for notifications';

-- =====================================================
-- DATABASE TRIGGER: AUTO-LOG ACTION CHANGES
-- =====================================================
-- Automatically insert into action_history when actions are updated
-- No need to manually log changes in application code

CREATE OR REPLACE FUNCTION log_action_changes()
RETURNS TRIGGER AS $$
BEGIN
  -- Update the updated_at timestamp
  NEW.updated_at = NOW();

  -- Track action_status changes
  IF OLD.action_status IS DISTINCT FROM NEW.action_status THEN
    INSERT INTO action_history (action_id, changed_by, field_changed, old_value, new_value, changed_at)
    VALUES (NEW.id, NEW.updated_by, 'action_status', OLD.action_status, NEW.action_status, NOW());
  END IF;

  -- Track assigned_to changes
  IF OLD.assigned_to IS DISTINCT FROM NEW.assigned_to THEN
    INSERT INTO action_history (action_id, changed_by, field_changed, old_value, new_value, changed_at)
    VALUES (NEW.id, NEW.updated_by, 'assigned_to',
            COALESCE(OLD.assigned_to::TEXT, 'unassigned'),
            COALESCE(NEW.assigned_to::TEXT, 'unassigned'), NOW());
  END IF;

  -- Track priority changes
  IF OLD.priority IS DISTINCT FROM NEW.priority THEN
    INSERT INTO action_history (action_id, changed_by, field_changed, old_value, new_value, changed_at)
    VALUES (NEW.id, NEW.updated_by, 'priority', OLD.priority, NEW.priority, NOW());
  END IF;

  -- Track due_date changes
  IF OLD.due_date IS DISTINCT FROM NEW.due_date THEN
    INSERT INTO action_history (action_id, changed_by, field_changed, old_value, new_value, changed_at)
    VALUES (NEW.id, NEW.updated_by, 'due_date',
            COALESCE(OLD.due_date::TEXT, 'no date'),
            COALESCE(NEW.due_date::TEXT, 'no date'), NOW());
  END IF;

  -- Track title changes
  IF OLD.title IS DISTINCT FROM NEW.title THEN
    INSERT INTO action_history (action_id, changed_by, field_changed, old_value, new_value, changed_at)
    VALUES (NEW.id, NEW.updated_by, 'title', OLD.title, NEW.title, NOW());
  END IF;

  -- Track description changes
  IF OLD.description IS DISTINCT FROM NEW.description THEN
    INSERT INTO action_history (action_id, changed_by, field_changed, old_value, new_value, changed_at)
    VALUES (NEW.id, NEW.updated_by, 'description',
            COALESCE(OLD.description, ''),
            COALESCE(NEW.description, ''), NOW());
  END IF;

  -- Track completion timestamp
  IF OLD.completed_at IS NULL AND NEW.completed_at IS NOT NULL THEN
    INSERT INTO action_history (action_id, changed_by, field_changed, old_value, new_value, changed_at)
    VALUES (NEW.id, NEW.updated_by, 'completed', 'false', 'true', NOW());
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop trigger if exists and recreate
DROP TRIGGER IF EXISTS action_audit_trigger ON actions;

CREATE TRIGGER action_audit_trigger
AFTER UPDATE ON actions
FOR EACH ROW
EXECUTE FUNCTION log_action_changes();

COMMENT ON FUNCTION log_action_changes() IS 'Automatically logs all changes to actions table';

-- =====================================================
-- UPDATE TRIGGER FOR updated_at COLUMNS
-- =====================================================
-- Automatically update updated_at timestamp on any update

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to all relevant tables
CREATE TRIGGER update_action_plan_drafts_updated_at BEFORE UPDATE ON action_plan_drafts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_action_comments_updated_at BEFORE UPDATE ON action_comments
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- GRANT PERMISSIONS (adjust for your database user)
-- =====================================================
-- Grant necessary permissions to your application user
-- Replace 'app_user' with your actual database username

-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
-- GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;

-- =====================================================
-- VERIFICATION QUERIES
-- =====================================================
-- Run these after setup to verify everything is created correctly

-- List all tables
-- SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name LIKE '%action%';

-- List all indexes
-- SELECT indexname FROM pg_indexes WHERE tablename LIKE '%action%';

-- List all triggers
-- SELECT trigger_name, event_object_table FROM information_schema.triggers WHERE trigger_name LIKE '%action%';

-- Test trigger (after creating an action)
-- UPDATE actions SET action_status = 'in_progress', updated_by = 1 WHERE id = 1;
-- SELECT * FROM action_history WHERE action_id = 1;
